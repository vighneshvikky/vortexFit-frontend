import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import {
  SchedulingRule,
  TimeSlot,
  DaySlots,
  SchedulingFormData,
} from '../models/scheduling.interface';
import { environment } from '../../../../enviorments/environment';
import { HttpClient } from '@angular/common/http';

@Injectable({
  providedIn: 'root',
})
export class SchedulingService {
  private apiUrl = `${environment.api}/schedules`;

  private rulesSubject = new BehaviorSubject<SchedulingRule[]>([]);
  private slotsSubject = new BehaviorSubject<TimeSlot[]>([]);

  public rules$ = this.rulesSubject.asObservable();
  public slots$ = this.slotsSubject.asObservable();

  constructor(private http: HttpClient) {
    this.loadFromStorage();
  }

  addRule(ruleData: SchedulingFormData): SchedulingRule {
    console.log('ruleData', ruleData);
    const newRule: SchedulingRule = {
      id: this.generateId(),
      ...ruleData,
      isActive: true,
    };

    const currentRules = this.rulesSubject.value;
    const updatedRules = [...currentRules, newRule];
    this.rulesSubject.next(updatedRules);
    this.saveToStorage();

    this.addSlotRule(newRule);

    return newRule;
  }

  updateRule(
    ruleId: string,
    updates: Partial<SchedulingRule>
  ): SchedulingRule | null {
    const currentRules = this.rulesSubject.value;
    const ruleIndex = currentRules.findIndex((rule) => rule.id === ruleId);

    if (ruleIndex === -1) return null;

    const updatedRule = { ...currentRules[ruleIndex], ...updates };
    const updatedRules = [...currentRules];
    updatedRules[ruleIndex] = updatedRule;

    this.rulesSubject.next(updatedRules);
    this.saveToStorage();

    // Send to backend
    this.updateSlotRule(updatedRule);

    return updatedRule;
  }

  deleteRule(ruleId: string): void {
    const currentRules = this.rulesSubject.value;
    const updatedRules = currentRules.filter((rule) => rule.id !== ruleId);
    this.rulesSubject.next(updatedRules);

    // Remove all slots generated by this rule
    const currentSlots = this.slotsSubject.value;
    const updatedSlots = currentSlots.filter(
      (slot) => !slot.id.startsWith(`rule_${ruleId}_`)
    );
    this.slotsSubject.next(updatedSlots);

    this.saveToStorage();

    // Send to backend
    this.deleteSlotRule(ruleId);
  }

  toggleRuleActive(ruleId: string): SchedulingRule | null {
    const currentRules = this.rulesSubject.value;
    const ruleIndex = currentRules.findIndex((rule) => rule.id === ruleId);

    if (ruleIndex === -1) return null;

    const updatedRule = {
      ...currentRules[ruleIndex],
      isActive: !currentRules[ruleIndex].isActive,
    };

    const updatedRules = [...currentRules];
    updatedRules[ruleIndex] = updatedRule;

    this.rulesSubject.next(updatedRules);
    this.saveToStorage();

    // Send to backend
    this.updateSlotRule(updatedRule);

    return updatedRule;
  }

  // Slot Management
  getSlotsForDate(date: string): TimeSlot[] {
    return this.slotsSubject.value.filter((slot) => slot.date === date);
  }

  getSlotsForDateRange(startDate: string, endDate: string): TimeSlot[] {
    return this.slotsSubject.value.filter(
      (slot) => slot.date >= startDate && slot.date <= endDate
    );
  }

  updateSlot(slotId: string, updates: Partial<TimeSlot>): TimeSlot | null {
    const currentSlots = this.slotsSubject.value;
    const slotIndex = currentSlots.findIndex((slot) => slot.id === slotId);

    if (slotIndex === -1) return null;

    const updatedSlot = { ...currentSlots[slotIndex], ...updates };
    const updatedSlots = [...currentSlots];
    updatedSlots[slotIndex] = updatedSlot;

    this.slotsSubject.next(updatedSlots);
    this.saveToStorage();

    return updatedSlot;
  }

  toggleSlotActive(slotId: string): TimeSlot | null {
    const currentSlots = this.slotsSubject.value;
    const slotIndex = currentSlots.findIndex((slot) => slot.id === slotId);

    if (slotIndex === -1) return null;

    const updatedSlot = {
      ...currentSlots[slotIndex],
      isActive: !currentSlots[slotIndex].isActive,
    };

    const updatedSlots = [...currentSlots];
    updatedSlots[slotIndex] = updatedSlot;

    this.slotsSubject.next(updatedSlots);
    this.saveToStorage();

    return updatedSlot;
  }

  deleteSlot(slotId: string): void {
    const currentSlots = this.slotsSubject.value;
    const updatedSlots = currentSlots.filter((slot) => slot.id !== slotId);
    this.slotsSubject.next(updatedSlots);
    this.saveToStorage();
  }

  // Calendar and Date Management
  generateCalendarData(year: number, month: number): DaySlots[] {
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startDate = new Date(firstDay);
    startDate.setDate(startDate.getDate() - firstDay.getDay());

    const calendarDays: DaySlots[] = [];

    for (let i = 0; i < 42; i++) {
      const date = new Date(startDate);
      date.setDate(startDate.getDate() + i);
      const dateString = this.formatDate(date);

      calendarDays.push({
        date: dateString,
        slots: this.getSlotsForDate(dateString),
        hasRecurringSlots: this.hasRecurringSlots(date),
      });
    }

    return calendarDays;
  }

  // Private helper methods
  private generateSlotsFromRule(rule: SchedulingRule): void {
    if (!rule.isActive) return;

    const currentSlots = this.slotsSubject.value;
    const newSlots: TimeSlot[] = [];

    // Generate slots for the date range specified in the rule
    const startDate = new Date(rule.startDate);
    const endDate = new Date(rule.endDate);

    for (
      let d = new Date(startDate);
      d <= endDate;
      d.setDate(d.getDate() + 1)
    ) {
      const date = new Date(d);

      // Check if this date is in exceptional days
      const dateString = this.formatDate(date);
      if (rule.exceptionalDays && rule.exceptionalDays.includes(dateString)) {
        continue; // Skip this date
      }

      if (rule.daysOfWeek.includes(date.getDay())) {
        const slots = this.generateSlotsForDate(rule, date);
        newSlots.push(...slots);
      }
    }

    // Remove existing slots for this rule and add new ones
    const filteredSlots = currentSlots.filter(
      (slot) => !slot.id.startsWith(`rule_${rule.id}_`)
    );
    this.slotsSubject.next([...filteredSlots, ...newSlots]);
    this.saveToStorage();
  }

  private generateSlotsForDate(rule: SchedulingRule, date: Date): TimeSlot[] {
    const slots: TimeSlot[] = [];
    const dateString = this.formatDate(date);

    const startTime = this.parseTime(rule.startTime);
    const endTime = this.parseTime(rule.endTime);
    const slotDuration = rule.slotDuration;

    let currentTime = startTime;

    while (currentTime + slotDuration <= endTime) {
      const slotStart = this.formatTime(currentTime);
      const slotEnd = this.formatTime(currentTime + slotDuration);

      slots.push({
        id: `rule_${rule.id}_${dateString}_${slotStart}`,
        startTime: slotStart,
        endTime: slotEnd,
        sessionType: rule.sessionType,
        isActive: true,
        date: dateString,
        bufferTime: rule.bufferTime,
        maxBookingsPerSlot: rule.maxBookingsPerSlot,
        currentBookings: 0,
      });

      currentTime += slotDuration + rule.bufferTime;
    }

    return slots;
  }

  private regenerateSlotsForRule(rule: SchedulingRule): void {
    this.generateSlotsFromRule(rule);
  }

  private updateSlotsForRule(rule: SchedulingRule): void {
    const currentSlots = this.slotsSubject.value;
    const updatedSlots = currentSlots.map((slot) => {
      if (slot.id.startsWith(`rule_${rule.id}_`)) {
        return { ...slot, isActive: rule.isActive };
      }
      return slot;
    });

    this.slotsSubject.next(updatedSlots);
    this.saveToStorage();
  }

  private hasRecurringSlots(date: Date): boolean {
    const dayOfWeek = date.getDay();
    return this.rulesSubject.value.some(
      (rule) => rule.isActive && rule.daysOfWeek.includes(dayOfWeek)
    );
  }

  private generateId(): string {
    return Date.now().toString() + Math.random().toString(36).substr(2, 9);
  }

  private formatDate(date: Date): string {
    return date.toISOString().split('T')[0];
  }

  private parseTime(timeString: string): number {
    const [hours, minutes] = timeString.split(':').map(Number);
    return hours * 60 + minutes;
  }

  private formatTime(minutes: number): string {
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return `${hours.toString().padStart(2, '0')}:${mins
      .toString()
      .padStart(2, '0')}`;
  }

  private saveToStorage(): void {
    try {
      localStorage.setItem(
        'trainer-scheduling-rules',
        JSON.stringify(this.rulesSubject.value)
      );
      localStorage.setItem(
        'trainer-scheduling-slots',
        JSON.stringify(this.slotsSubject.value)
      );
    } catch (error) {
      console.error('Error saving to storage:', error);
    }
  }

  private loadFromStorage(): void {
    try {
      const storedRules = localStorage.getItem('trainer-scheduling-rules');
      const storedSlots = localStorage.getItem('trainer-scheduling-slots');

      if (storedRules) {
        this.rulesSubject.next(JSON.parse(storedRules));
      }

      if (storedSlots) {
        this.slotsSubject.next(JSON.parse(storedSlots));
      }
    } catch (error) {
      console.error('Error loading from storage:', error);
    }
  }

  public addSlotRule(rule: SchedulingRule): Observable<SchedulingRule> {
    return this.http.post<SchedulingRule>(`${this.apiUrl}/create`, rule);
  }

  private updateSlotRule(rule: SchedulingRule) {
    return this.http.put(`${this.apiUrl}/rule/${rule.id}`, rule).subscribe({
      next: (response) => {
        console.log('Rule updated successfully:', response);
      },
      error: (error) => {
        console.error('Error updating rule:', error);
      },
    });
  }

  private deleteSlotRule(ruleId: string) {
    return this.http.delete(`${this.apiUrl}/rule/${ruleId}`).subscribe({
      next: (response) => {
        console.log('Rule deleted successfully:', response);
      },
      error: (error) => {
        console.error('Error deleting rule:', error);
      },
    });
  }

  getSchedule(): Observable<SchedulingRule[]> {
    console.log('calling getschedules');
    return this.http.get<SchedulingRule[]>(`${this.apiUrl}/getSchedules`);
  }

  deleteSchedule(id: string): Observable<SchedulingRule> {
    return this.http.delete<SchedulingRule>(
      `${this.apiUrl}/deleteSchedule/${id}`
    );
  }
}
